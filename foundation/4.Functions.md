# 函数与生成器

## def 语句

> def 创建函数

```python
def name(arg1, arg2,... argN):
    statements
```

> 定义和调用

```python
>>> def times(x, y): # Create and assign function
...     return x * y # Body executed when called
...
>>> times(2, 4) # Arguments in parentheses
8
>>> times('Ni', 4) # Functions are "typeless"
'NiNiNiNi'
```

> Python 中的多态(Polymorphism)  
> 一个操作的意义取决于对象类型的行为叫做多态。例如上述示例展现的*根据传入对象的类型来决定是乘积还是重复

## 作用域

* 变量名解析 LEGB 原则

|     |                           |                                     |
| --- | ------------------------- | ----------------------------------- |
| L   | Local(function)           | 函数内的名字空间                    |
| E   | Enclosing function locals | 外部嵌套函数的名字空间(例如closure) |
| G   | Global(module)            | 函数定义所在模块（文件）的名字空间  |
| B   | Builtin(Python)           | Python内置模块的名字空间            |

* 示例

```python
# Global scope
X = 99 # X and func assigned in module: global
def func(Y): # Y and Z assigned in function: locals
    # Local scope
    Z = X + Y # X is a global
    return Z

func(1) # func in module: result=100
```

> x, func 全局变量
> Y, Z 本地变量  
> 注意：本地变量会覆盖全局变量

* global nonlocal 语句  

 > global 从嵌套模块作用域开始查找  
 > nonlocal 从嵌套的def中查找，默认嵌套def中的变量不可被修改，nonlocal 使得嵌套中的变量可以被修改

## 参数

> **参数传递是通过将对象赋值给本地变量来完成**

* 参数匹配模型

1. 位置：从左至右进行匹配
2. 关键字参数：根据参数名称进行匹配
3. 默认参数：没有传入是设置默认值
4. 可变参数：收集任意多的位置或者关键字参数(def定义)
5. 可变参数解包：传递任意多的位置或者关键字参数(调用者)
6. keyword-only：参数必须按照名称传递

### def定义

* 位置、默认值

  def func(name)
  def func(name=value)

* 可变参数
  
  def func(*args)
  def func(**args)
  def func(*args,name)

### 调用

* 位置、关键字

  func(var)
  func(name=var)

* 可变参数解包
  
  func(*seq)
  func(**dict)
